/**
 * Insight Entity Service
 * Manages insights generated by pattern detection and analysis services
 *
 * Insights are actionable findings derived from:
 * - Burnout pattern detection
 * - Process degradation analysis
 * - Team conflict detection
 * - Bus factor analysis
 * - Data quality issues
 */

import { Pool } from 'pg';
import { PrismaClient } from '@prisma/client';

export interface Insight {
  id: string;
  organizationId: string;
  type: InsightType;
  category: InsightCategory;
  severity: InsightSeverity;
  status: InsightStatus;
  title: string;
  description: string;
  entityType: EntityType;
  entityId: string;
  entityName?: string;
  score: number;
  confidence: number;
  metadata: Record<string, unknown>;
  recommendedActions: string[];
  acknowledgedBy?: string;
  acknowledgedAt?: Date;
  resolvedBy?: string;
  resolvedAt?: Date;
  resolutionNotes?: string;
  expiresAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export type InsightType =
  | 'burnout_risk'
  | 'process_degradation'
  | 'team_conflict'
  | 'bus_factor_risk'
  | 'data_quality'
  | 'compliance_gap'
  | 'opportunity'
  | 'anomaly';

export type InsightCategory =
  | 'people'
  | 'process'
  | 'team'
  | 'organization'
  | 'data'
  | 'compliance';

export type InsightSeverity = 'low' | 'medium' | 'high' | 'critical';

export type InsightStatus = 'new' | 'acknowledged' | 'in_progress' | 'resolved' | 'dismissed' | 'expired';

export type EntityType = 'person' | 'process' | 'team' | 'domain' | 'data_source' | 'organization';

export interface CreateInsightInput {
  organizationId: string;
  type: InsightType;
  category: InsightCategory;
  severity: InsightSeverity;
  title: string;
  description: string;
  entityType: EntityType;
  entityId: string;
  entityName?: string;
  score: number;
  confidence?: number;
  metadata?: Record<string, unknown>;
  recommendedActions?: string[];
  expiresAt?: Date;
}

export interface UpdateInsightInput {
  status?: InsightStatus;
  severity?: InsightSeverity;
  acknowledgedBy?: string;
  resolvedBy?: string;
  resolutionNotes?: string;
}

export interface InsightQueryOptions {
  organizationId: string;
  types?: InsightType[];
  categories?: InsightCategory[];
  severities?: InsightSeverity[];
  statuses?: InsightStatus[];
  entityTypes?: EntityType[];
  entityId?: string;
  minScore?: number;
  from?: Date;
  to?: Date;
  limit?: number;
  offset?: number;
  orderBy?: 'createdAt' | 'score' | 'severity';
  orderDirection?: 'asc' | 'desc';
}

export interface InsightSummary {
  totalCount: number;
  bySeverity: Record<InsightSeverity, number>;
  byCategory: Record<InsightCategory, number>;
  byStatus: Record<InsightStatus, number>;
  avgScore: number;
  criticalCount: number;
  unresolvedCount: number;
}

export class InsightService {
  private pool: Pool;
  private prisma: PrismaClient;

  constructor(pool: Pool, prisma: PrismaClient) {
    this.pool = pool;
    this.prisma = prisma;
  }

  /**
   * Create a new insight
   */
  async createInsight(input: CreateInsightInput): Promise<Insight> {
    const {
      organizationId,
      type,
      category,
      severity,
      title,
      description,
      entityType,
      entityId,
      entityName,
      score,
      confidence = 0.7,
      metadata = {},
      recommendedActions = [],
      expiresAt,
    } = input;

    // Check for duplicate/similar insight within the last 7 days
    const existingQuery = `
      SELECT id FROM insights
      WHERE organization_id = $1
        AND type = $2
        AND entity_id = $3
        AND status NOT IN ('resolved', 'dismissed', 'expired')
        AND created_at > NOW() - INTERVAL '7 days'
      LIMIT 1
    `;

    const existing = await this.pool.query(existingQuery, [
      organizationId,
      type,
      entityId,
    ]);

    if (existing.rows.length > 0) {
      // Update existing insight instead of creating duplicate
      return this.updateExistingInsight(existing.rows[0].id, {
        severity,
        score,
        description,
        metadata,
        recommendedActions,
      });
    }

    const insertQuery = `
      INSERT INTO insights (
        id, organization_id, type, category, severity, status,
        title, description, entity_type, entity_id, entity_name,
        score, confidence, metadata, recommended_actions, expires_at,
        created_at, updated_at
      ) VALUES (
        gen_random_uuid(), $1, $2, $3, $4, 'new',
        $5, $6, $7, $8, $9,
        $10, $11, $12, $13, $14,
        NOW(), NOW()
      )
      RETURNING *
    `;

    const result = await this.pool.query(insertQuery, [
      organizationId,
      type,
      category,
      severity,
      title,
      description,
      entityType,
      entityId,
      entityName || null,
      score,
      confidence,
      JSON.stringify(metadata),
      recommendedActions,
      expiresAt || null,
    ]);

    return this.mapRowToInsight(result.rows[0]);
  }

  /**
   * Update existing insight with new data
   */
  private async updateExistingInsight(
    id: string,
    updates: {
      severity?: InsightSeverity;
      score?: number;
      description?: string;
      metadata?: Record<string, unknown>;
      recommendedActions?: string[];
    }
  ): Promise<Insight> {
    const updateQuery = `
      UPDATE insights
      SET severity = COALESCE($1, severity),
          score = COALESCE($2, score),
          description = COALESCE($3, description),
          metadata = COALESCE($4, metadata),
          recommended_actions = COALESCE($5, recommended_actions),
          updated_at = NOW()
      WHERE id = $6
      RETURNING *
    `;

    const result = await this.pool.query(updateQuery, [
      updates.severity || null,
      updates.score || null,
      updates.description || null,
      updates.metadata ? JSON.stringify(updates.metadata) : null,
      updates.recommendedActions || null,
      id,
    ]);

    return this.mapRowToInsight(result.rows[0]);
  }

  /**
   * Get insight by ID
   */
  async getInsightById(id: string): Promise<Insight | null> {
    const query = `
      SELECT * FROM insights WHERE id = $1
    `;

    const result = await this.pool.query(query, [id]);

    if (result.rows.length === 0) {
      return null;
    }

    return this.mapRowToInsight(result.rows[0]);
  }

  /**
   * Query insights with filters
   */
  async queryInsights(options: InsightQueryOptions): Promise<Insight[]> {
    const conditions: string[] = ['organization_id = $1'];
    const values: unknown[] = [options.organizationId];
    let paramIndex = 2;

    if (options.types && options.types.length > 0) {
      conditions.push(`type = ANY($${paramIndex++})`);
      values.push(options.types);
    }

    if (options.categories && options.categories.length > 0) {
      conditions.push(`category = ANY($${paramIndex++})`);
      values.push(options.categories);
    }

    if (options.severities && options.severities.length > 0) {
      conditions.push(`severity = ANY($${paramIndex++})`);
      values.push(options.severities);
    }

    if (options.statuses && options.statuses.length > 0) {
      conditions.push(`status = ANY($${paramIndex++})`);
      values.push(options.statuses);
    }

    if (options.entityTypes && options.entityTypes.length > 0) {
      conditions.push(`entity_type = ANY($${paramIndex++})`);
      values.push(options.entityTypes);
    }

    if (options.entityId) {
      conditions.push(`entity_id = $${paramIndex++}`);
      values.push(options.entityId);
    }

    if (options.minScore !== undefined) {
      conditions.push(`score >= $${paramIndex++}`);
      values.push(options.minScore);
    }

    if (options.from) {
      conditions.push(`created_at >= $${paramIndex++}`);
      values.push(options.from);
    }

    if (options.to) {
      conditions.push(`created_at <= $${paramIndex++}`);
      values.push(options.to);
    }

    const orderBy = options.orderBy || 'createdAt';
    const orderColumn = orderBy === 'createdAt' ? 'created_at' : orderBy;
    const orderDirection = options.orderDirection || 'desc';
    const limit = options.limit || 50;
    const offset = options.offset || 0;

    const query = `
      SELECT * FROM insights
      WHERE ${conditions.join(' AND ')}
      ORDER BY
        CASE severity
          WHEN 'critical' THEN 1
          WHEN 'high' THEN 2
          WHEN 'medium' THEN 3
          WHEN 'low' THEN 4
        END,
        ${orderColumn} ${orderDirection}
      LIMIT ${limit} OFFSET ${offset}
    `;

    const result = await this.pool.query(query, values);

    return result.rows.map((row) => this.mapRowToInsight(row));
  }

  /**
   * Get insight summary for organization
   */
  async getInsightSummary(organizationId: string): Promise<InsightSummary> {
    const query = `
      SELECT
        COUNT(*) as total_count,
        COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,
        COUNT(*) FILTER (WHERE severity = 'high') as high_count,
        COUNT(*) FILTER (WHERE severity = 'medium') as medium_count,
        COUNT(*) FILTER (WHERE severity = 'low') as low_count,
        COUNT(*) FILTER (WHERE category = 'people') as people_count,
        COUNT(*) FILTER (WHERE category = 'process') as process_count,
        COUNT(*) FILTER (WHERE category = 'team') as team_count,
        COUNT(*) FILTER (WHERE category = 'organization') as org_count,
        COUNT(*) FILTER (WHERE category = 'data') as data_count,
        COUNT(*) FILTER (WHERE category = 'compliance') as compliance_count,
        COUNT(*) FILTER (WHERE status = 'new') as new_count,
        COUNT(*) FILTER (WHERE status = 'acknowledged') as acknowledged_count,
        COUNT(*) FILTER (WHERE status = 'in_progress') as in_progress_count,
        COUNT(*) FILTER (WHERE status = 'resolved') as resolved_count,
        COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed_count,
        COUNT(*) FILTER (WHERE status = 'expired') as expired_count,
        COUNT(*) FILTER (WHERE status NOT IN ('resolved', 'dismissed', 'expired')) as unresolved_count,
        AVG(score) as avg_score
      FROM insights
      WHERE organization_id = $1
        AND created_at > NOW() - INTERVAL '30 days'
    `;

    const result = await this.pool.query(query, [organizationId]);
    const row = result.rows[0];

    return {
      totalCount: parseInt(row.total_count) || 0,
      bySeverity: {
        critical: parseInt(row.critical_count) || 0,
        high: parseInt(row.high_count) || 0,
        medium: parseInt(row.medium_count) || 0,
        low: parseInt(row.low_count) || 0,
      },
      byCategory: {
        people: parseInt(row.people_count) || 0,
        process: parseInt(row.process_count) || 0,
        team: parseInt(row.team_count) || 0,
        organization: parseInt(row.org_count) || 0,
        data: parseInt(row.data_count) || 0,
        compliance: parseInt(row.compliance_count) || 0,
      },
      byStatus: {
        new: parseInt(row.new_count) || 0,
        acknowledged: parseInt(row.acknowledged_count) || 0,
        in_progress: parseInt(row.in_progress_count) || 0,
        resolved: parseInt(row.resolved_count) || 0,
        dismissed: parseInt(row.dismissed_count) || 0,
        expired: parseInt(row.expired_count) || 0,
      },
      avgScore: parseFloat(row.avg_score) || 0,
      criticalCount: parseInt(row.critical_count) || 0,
      unresolvedCount: parseInt(row.unresolved_count) || 0,
    };
  }

  /**
   * Update insight status
   */
  async updateInsight(id: string, input: UpdateInsightInput): Promise<Insight | null> {
    const updates: string[] = ['updated_at = NOW()'];
    const values: unknown[] = [];
    let paramIndex = 1;

    if (input.status) {
      updates.push(`status = $${paramIndex++}`);
      values.push(input.status);

      // Set acknowledged/resolved timestamps
      if (input.status === 'acknowledged' && input.acknowledgedBy) {
        updates.push(`acknowledged_by = $${paramIndex++}`);
        values.push(input.acknowledgedBy);
        updates.push(`acknowledged_at = NOW()`);
      }

      if (input.status === 'resolved' && input.resolvedBy) {
        updates.push(`resolved_by = $${paramIndex++}`);
        values.push(input.resolvedBy);
        updates.push(`resolved_at = NOW()`);
      }
    }

    if (input.severity) {
      updates.push(`severity = $${paramIndex++}`);
      values.push(input.severity);
    }

    if (input.resolutionNotes) {
      updates.push(`resolution_notes = $${paramIndex++}`);
      values.push(input.resolutionNotes);
    }

    values.push(id);

    const query = `
      UPDATE insights
      SET ${updates.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `;

    const result = await this.pool.query(query, values);

    if (result.rows.length === 0) {
      return null;
    }

    return this.mapRowToInsight(result.rows[0]);
  }

  /**
   * Acknowledge an insight
   */
  async acknowledgeInsight(id: string, userId: string): Promise<Insight | null> {
    return this.updateInsight(id, {
      status: 'acknowledged',
      acknowledgedBy: userId,
    });
  }

  /**
   * Resolve an insight
   */
  async resolveInsight(
    id: string,
    userId: string,
    notes?: string
  ): Promise<Insight | null> {
    return this.updateInsight(id, {
      status: 'resolved',
      resolvedBy: userId,
      resolutionNotes: notes,
    });
  }

  /**
   * Dismiss an insight
   */
  async dismissInsight(id: string, userId: string, reason?: string): Promise<Insight | null> {
    return this.updateInsight(id, {
      status: 'dismissed',
      resolvedBy: userId,
      resolutionNotes: reason || 'Dismissed by user',
    });
  }

  /**
   * Get insights requiring immediate attention
   */
  async getUrgentInsights(organizationId: string, limit = 10): Promise<Insight[]> {
    return this.queryInsights({
      organizationId,
      severities: ['critical', 'high'],
      statuses: ['new', 'acknowledged'],
      limit,
      orderBy: 'score',
      orderDirection: 'desc',
    });
  }

  /**
   * Get insights for a specific entity
   */
  async getEntityInsights(
    organizationId: string,
    entityType: EntityType,
    entityId: string
  ): Promise<Insight[]> {
    return this.queryInsights({
      organizationId,
      entityTypes: [entityType],
      entityId,
      statuses: ['new', 'acknowledged', 'in_progress'],
    });
  }

  /**
   * Expire old insights
   */
  async expireOldInsights(organizationId: string): Promise<number> {
    const query = `
      UPDATE insights
      SET status = 'expired', updated_at = NOW()
      WHERE organization_id = $1
        AND status NOT IN ('resolved', 'dismissed', 'expired')
        AND (
          (expires_at IS NOT NULL AND expires_at < NOW())
          OR created_at < NOW() - INTERVAL '90 days'
        )
    `;

    const result = await this.pool.query(query, [organizationId]);
    return result.rowCount || 0;
  }

  /**
   * Delete old resolved/dismissed insights
   */
  async cleanupOldInsights(organizationId: string, retentionDays = 365): Promise<number> {
    const query = `
      DELETE FROM insights
      WHERE organization_id = $1
        AND status IN ('resolved', 'dismissed', 'expired')
        AND updated_at < NOW() - INTERVAL '${retentionDays} days'
    `;

    const result = await this.pool.query(query, [organizationId]);
    return result.rowCount || 0;
  }

  /**
   * Map database row to Insight object
   */
  private mapRowToInsight(row: Record<string, unknown>): Insight {
    return {
      id: row.id as string,
      organizationId: row.organization_id as string,
      type: row.type as InsightType,
      category: row.category as InsightCategory,
      severity: row.severity as InsightSeverity,
      status: row.status as InsightStatus,
      title: row.title as string,
      description: row.description as string,
      entityType: row.entity_type as EntityType,
      entityId: row.entity_id as string,
      entityName: row.entity_name as string | undefined,
      score: parseFloat(row.score as string) || 0,
      confidence: parseFloat(row.confidence as string) || 0,
      metadata: (row.metadata as Record<string, unknown>) || {},
      recommendedActions: (row.recommended_actions as string[]) || [],
      acknowledgedBy: row.acknowledged_by as string | undefined,
      acknowledgedAt: row.acknowledged_at ? new Date(row.acknowledged_at as string) : undefined,
      resolvedBy: row.resolved_by as string | undefined,
      resolvedAt: row.resolved_at ? new Date(row.resolved_at as string) : undefined,
      resolutionNotes: row.resolution_notes as string | undefined,
      expiresAt: row.expires_at ? new Date(row.expires_at as string) : undefined,
      createdAt: new Date(row.created_at as string),
      updatedAt: new Date(row.updated_at as string),
    };
  }
}

// Factory function
let insightServiceInstance: InsightService | null = null;

export function createInsightService(pool: Pool, prisma: PrismaClient): InsightService {
  if (!insightServiceInstance) {
    insightServiceInstance = new InsightService(pool, prisma);
  }
  return insightServiceInstance;
}

export function resetInsightService(): void {
  insightServiceInstance = null;
}
